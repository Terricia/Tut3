#Terricia Govender
#212505648
#Tut3: Question 4 and Bonus Question

import numpy as np
from matplotlib import pylab as plt
def sim_Gaussian(t,sig=0.5,amp=1,cent=0):
    d=np.exp(-0.5*(t-cent)**2/sig**2)*amp
    d+=np.random.randn(t.size)
    return d


def trial_offset(sigs):
    return sigs*numpy.random.randn(sigs.size)

class Gaussian:
    def __init__(self,t,sig=0.5,amp=1.0,cent=0,offset=0):
        self.t=t
        self.y=sim_Gaussian(t,sig,amp,cent)+offset
        self.err=numpy.ones(t.size)
        self.sig=sig
        self.amp=amp
        self.cent=cent
        self.offset=offset

    def __chisquare__(self,vec):
        sig=vec[0]
        amp=vec[1]
        cent=vec[2]
        off=vec[3]

        det=off+amp*numpy.exp(-0.5*(self.t-cent)**2/sig**2)
        chisquare=numpy.sum(  (self.y-det)**2/self.err**2)
        return chisquare

def run_mcmc(d,begin_pos,nstep,scale=None):
    npar=begin_pos.size
    par=np.zeros([nstep,npar+1])
    par[0,0:-1]=begin_pos
    current_chisquare=data.get_chisq(begin_pos)
    currrent_pos=start_pos.copy()
    if scale==None:
        scale=np.ones(npar)
    #run chain
    tot_accept=0.0
    tot_reject=0.0
    for i in range(1,nstep):
        new_pos=current_pos+trial_offset(scale)
        new_chisq=data.get_chisq(new_pos)
        if new_chisq<current_chisquare:
            accept=True
        else:
            delt=new_chisq-current_chisquare
            prob=np.exp(-0.5*delt)
            if np.random.rand()<prob:
                accept=True
            else:
                accept=False
        if accept:
            tot_accept=tot_accept+1
            current_pos=new_pos
            current_chisquare=new_chisq
        else:
            tot_reject=tot_reject+1
        par[i,0:-1]=current_pos
        par[i,-1]=current_chisquare
        accept_frac=tot_accept/(tot_accept+tot_reject)
    return par,accept_frac


if __name__=='__main__':
    
    #gaussian, with noise
    t=np.arange(-5,5,0.01)
    d=Gaussian(t,amp=2.5)

    #pick starting position and guess few errors
    guess=np.array([0.3,1.2,0.3,-0.2])
    scale=np.array([0.1,0.1,0.1,0.1])

    #short chain
    nstep=1000
    chain,accept=run_mcmc(d,guess,nstep,scale)
    q=np.round(0.2*nstep)
    chain=chain[q:,:]
    

    #standard deviation of parameters
    scale=np.std(chain[:,0:-1],0)
    
    nstep=30000
    chain,accept2=run_mcmc(d,chain[-1,0:-1],nstep,scale)
    print ("old accept was: ") + (repr(accept))
    print ("new accept is: ") + (repr(accept2))
    
    #compare
    par_true=np.array([d.sig,d.amp,d.cent,d.offset])
    for i in range(0,par_true.size):
        num=np.mean(chain[:,i])
        s=np.std(chain[:,i])
        print ([par_true[i],num,s])

