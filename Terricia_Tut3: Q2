#Terricia Govender
#212505648
#Tut 3: Question 2

import numpy as np
from matplotlib import pyplot as plt

class Particles:
    def __init__(self,n=1000,G=1.0,soft=0.1):
        self.x=np.random.randn(n)
        self.y=np.random.randn(n)
        self.m=np.ones(n)*(1.0/n)
        self.vx=np.zeros(n)
        self.vy=np.zeros(n)
        self.opts={}
        self.opts['n']=n
        self.opts['G']=G
        self.opts['soft']=soft
    def get_forces(self):
        pot=0
        self.fx=np.zeros(self.opts['n'])
        self.fy=np.zeros(self.opts['n'])
        for i in range(0,self.opts['n']-1):
            dx=self.x[i]-self.x[i+1:]
            dy=self.y[i]-self.y[i+1:]
            rsqr=(dx*dx+dy*dy)
            rsqr[rsqr<self.opts['soft']]=self.opts['soft']
            r=np.sqrt(rsqr)
            r3inv=1.0/(r*rsqr)
            self.fx[i]-=np.sum(dx*r3inv*self.m[i+1:])
            self.fy[i]-=np.sum(dy*r3inv*self.m[i+1:])
            self.fx[i+1:]+=dx*r3inv*self.m[i]
            self.fy[i+1:]+=dy*r3inv*self.m[i]
            pot=pot+np.sum(self.opts['G']*self.m[i]*self.m[i+1:]*1.0/r)
        self.fx=self.fx*self.opts['G']
        self.fy=self.fy*self.opts['G']
        return pot
        
    def update_pos(self,dt=0.1):
        self.x+=self.vx*dt
        self.y+=self.vy*dt
        pot=self.get_forces()
        self.vx+=self.fx*dt
        self.vy+=self.fy*dt
        return pot
            

    def get_potential(self):
        pot=np.zeros(self.opts['n'])
        for i in range(0,self.opts['n']):
            dx=self.x[i]-self.x
            dy=self.y[i]-self.y
            r=np.sqrt(dx*dx+dy*dy)
            rinv=1.0/r
            rinv[i]=0
            pot[i]=self.m[i]+np.sum(self.opts['G']*self.m[i]*self.m*rinv)
        return pot

if __name__=='__main__':
    part=Particles()
    
    pot_init=part.get_forces()
    print ("initial energy is ") + (repr(pot_init))
    plt.ion()
    nstep=200
    a=np.zeros(nstep)
    b=np.zeros(nstep)
    for xx in range(0,nstep):
        
        pot=part.update_pos(0.05)        
        plt.clf()
        plt.plot(part.x,part.y,'*')
        plt.draw()
        ke=np.sum(part.m*(part.vx**2+part.vy**2))
        print ('total energy is ') + (repr([pot,ke,kin-2.0*pot]))
        a[xx]=pot
        b[xx]=kin
